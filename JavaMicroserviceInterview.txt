Array and array list (when array is used and when arraylist is used)
Linked list ( why we prefer linkedlist over arraylist)
Constructor
Threads in Java - dead lock

Spring boot application properties (application properties.test, application unit test properties) --> it is used for profiling. there are multiple environment, for example we deploy in production, but before that we have dev environment and test environment. so we give configuration over there in application properties for each profiles.)

sping framework yaml
Different configurations in spring boot

Core Java
Garbage collection (--> If there is one object but now the object is not in use, then garbage collection remove the object from memory. we can not forcefully do garbage collection method)

Finalised method in garbage collection (--> here it is used for clean up activity)

Spring literals - constant pool - immutable

if question --> sysout(1+2+"welcome"+5+6) -- output -> 3wlecome56 {before string it it is treated as integer, after string it is treated as string for numbers also}

Strings in Java - buffer - builder  (which is more efficent?)  ---> buffer is thread safe and syncronized. builder is not thread safe so it is not taking time and execution is more faster.

Exceptions - checked (--> it is checked at compile time for eg: file not found exception. we get the error at compile time) - runtime (-- error got at runtime, for example arithmatic exception. it is also called as unchecked exception)

Handling exceptions  (--> try catch and user define exception(by using throw keyword))

Comparable (--> it is used for single sorting. for example, if we want to sort by empId only) & comparator (-- it is used for multiple sorting. for example, if we want to sort by empId, name, salary)
In Comparable compareTo() method is used to sort elements. And in comparator compare() method is used to sort elements.
We use comparator than comparable when we want to pass the comparation logic.
Comparable is present in the package java.lang. And Comparator is present in the package java.util.
  
Singleton class (--> where only one object is created. by making constructor private we make singleton. We do this so that no one can create new object by using new keyword. Also if we have static method.)

Java 8. use of Lambda? (--> The three primary reasons why we need Java Lambda expressions are as follows: Lambda converts the code segment into an argument. It is a method that can be created without instantiating a class. Lambda can be treated as an Object.)

Optional (--> it is used to avoid null pointer exception. if in one scenerio if the object may be null then we can use optional. isPresent, isEmpty are methods inside Optional class)

SQL connection (how it is connected to database in the project?) 
How JDBC is used to connect with database? (--> first we register the driver, then by creating the connection, passing query for execution and after that we close the connection and connected to the database.)

Pom.xml (--> it is a file where we add the dependency. if we give the dependency in pom.xml it will download it from internet or other environment.)

Tools to used for commit code? if want to change one application code, then how you get it from git? (--> first we create one folder in my local machine. Then by giving git clone command we will clone the code from remote repository to my local repository)

------------------------------------------------------------------------------------------------------------------------------------------------------------


Q. Why strings are immutable and final in java?
Ans:- Security. Multithreading. If one reference variable change its value, then it will be affected by all the other reference variables.

Q. C++ vs Java?
Ans:- C++ --> Platform dependent. Supports multiple inheritance. Operator overloading. No built-in support for thread.
 
Java --> Platform Independent. No multiple inheritance. No Operator overloading. Built-in support for thread.


Q. Story points in Agile.
Ans:- Story points in Agile is a measurement that developers use instead of hours. Where as story is a feature that need to make by the developer. 


Q. JDK vs JVM vs JRE
Ans:- JDK  --> JRE + Development tools(Java, Javac). develop and run
      JVM  --> Interpreter part of both JDK and JRE. To run java program line by line.
      JRE  --> Only run java application.

Q. Why Java is not fully object oriented?
Ans:- In java we support int, float, double data types, which are not object oriented.

Q. Method overloading vs Method Overriding?
Ans:- Method overloading means change in function signature. Where as Method overriding means inheretance (means parent class child class).

Q. JPA vs Hibernate?
Ans:- JPA:- It is like an interface and have no concrete implementation of it to use functions which are in JPA.
Hibernate:- It is just a JPA provider which have implementation of the functions in JPA and can have some extra functions which might not be there in JPA.

Q. Spring vs Spring Boot?
Ans:- Spring --> Dependency Injection. We need to set up the servers explicitly. No support for in memory database.
Spring Boot --> Spring Boot is a module of Spring framework. Autoconfiguration. Embedded Server. In-memory database.

Q. Agile vs Scrum?
Ans:- Agile --> Agile is a development methodology. In Agile the leadership plays the vital role.
Scrum --> Scrum is the one of the implementation of Agile. In which incremental builds are delivered to the customer in every two or three weeks of time. Scrum fosters a self organizing, cross functional team.  

Q. How to overload and Override the Main method in Java?
Ans:- We cannot Override the main method, because we cannot override static method. 
We can Overload main method.

************************************************************************************************************************************************************

Q. What is dynamic binding?
Ans:- Dynamic binding is a feature of polymorphism. for example there is a parent class and a child class. If you want to refer object of parent class or child class then that needs to be decided in dynamically runtime, so in that you can call this as dynamic binding.

Q. What are the different ways to create thread in java?
Ans:- 1) By extending Thread class.
2) By implementing Runnable interface. (to implement runnable interface we need to override run method)

Q. States of thread?
Ans:- new state, runnable, wait/sleep, resume, terminated/stop.

Q. What is deadlock in thread?
Ans: - A deadlock occurs when two or more threads are blocked and unable to proceed because they are waiting for each other to release a lock.

Q. Is it mandatory to have catch block?
Ans:- Not mandatory but there must be one block after try. It can be catch or it can be finally.

Q. What is the significance of HashMap?
Ans:- To store data in key value pair we use HashMap.

Q. Concept of bucketing in HashMap?
Ans:- Buckets: A HashMap is an array of “buckets.” Each bucket can hold one or more key-value pairs. The goal is to distribute the key-value pairs across these buckets evenly to improve retrieval performance.

Q. Normal HashMap vs Concurrent HashMap?
Ans:- HashMap is the Class which is under Traditional Collection and ConcurrentHashMap is a Class which is under Concurrent Collections, apart from this there are various differences between them which are:

1) HashMap is non-Synchronized in nature i.e. HashMap is not Thread-safe whereas ConcurrentHashMap is Thread-safe in nature.

2) HashMap performance is relatively high because it is non-synchronized in nature and any number of threads can perform simultaneously. But ConcurrentHashMap performance is low sometimes because sometimes Threads are required to wait on ConcurrentHashMap.

3) While one thread is Iterating the HashMap object, if other thread try to add/modify the contents of Object then we will get Run-time exception saying ConcurrentModificationException.Whereas In ConcurrentHashMap we wont get any exception while performing any modification at the time of Iteration.



Q. How you connect database in spring boot?
Ans:- first we need to give database connection in pom.xml file. Then after that we declare database connection in applocation.properties file where we can define the database like we can give username, password, drivers that create connection etc.

In java side we use JPA repository to perform database related connection.

Q. To monitor Application what we can use in spring boot application?
Ans:- We can use Actuator. Also we can use Spring boot Admin server.

Q. Where you deploy Spring boot application?
Ans:- In local we use Tomcat server to deploy our application which is embedded in Spring boot already.

Q. How many instances we can use to deploy our application?
Ans:- We can use n number of instances it depends. For example I am deploying in dev environment then we use that instance.

Q. Why we use microservices in spring boot?
Ans:- Microservices improve performance because teams handle specific services rather than an app as a whole.
Microservices architecture provides flexibility for plug-and-play upgrades, simplifying the scaling of specific components within an application without impacting the entire system. Containers are the primary means of deploying microservices on cloud platforms such as Amazon AWS and Microsoft Azure.

Q. Why we need indexing in database?
Ans:- The objective of indexing is to organize and categorize information in a way that makes it easier to retrieve and access. It involves creating a list of keywords or terms associated with specific pieces of information, making it easier to find relevant information quickly.

Q. What is normalization in database?
Ans:- Normalization is the process of organizing data in a database. It includes creating tables and establishing relationships between those tables according to rules designed both to protect the data and to make the database more flexible by eliminating redundancy and inconsistent dependency.

Q. What is primary key and foreign key in database?
Ans:- Primary keys serve as unique identifiers for each row in a database table. Foreign keys link data in one table to the data in another table. A foreign key column in a table points to a column with unique values in another table (often the primary key column) to create a way of cross-referencing the two tables.

************************************************************************************************************************************************************

Q. How Spring boot is better than Spring?
Ans:- 1) Configuration is better. It allows developers to create standalone applications with no or little configuration.
2) In sping boot we have embedded servers like tomcat, jetty so easy to deploy.
3) Dependency management. we can use annotation based configuration for that.

Q. What is dependency injection?
Ans:- DI means you are injecting a dependency. for eg: there is a class employee, and there are some method inside it. So when we need the instance of the particular employee bean then we need dependency injection. It helps in bean life cycle by decoupling bean creation and configuration. Two ways constructor injection and setter based injection to inject dependency.

Q. Most common annotation in Spring boot?
Ans:- @Spring boot application  --> 
@Rest controller   -->
@get, @put, @post
@autowired   --> 


Q. How to handle exception in Spring boot?
Ans:- Exception handling in Spring Boot helps to deal with errors and exceptions present in APIs, delivering a robust enterprise application. This article covers various ways in which exceptions can be handled and how to return meaningful error responses to the client in a Spring Boot Project.

Here are some key approaches to exception handling in Spring Boot:

Default exception handling by Spring Boot
Using @ExceptionHandler annotation
Using @ControllerAdvice for global exception handling


Q. In Rest Api how to connect to database?
Ans:- First include the dependency in pom.xml file, then in application.properties give database related properties. Then In controller layer we can write the endpoints which need to be excuted like get mapping. then from that give a call to service layer, then to DAO or repository layer. At repository layer we can perform simple crud operations.

Q. How to manage transaction in spring boot?
Ans:- By giving @transaction annotation in service layer.
Transaction --> Suppose there is a function deposit and by calling that method we retrieve money then it is called transaction.

Q. How two microservices communicate with each other?
Ans:- Microservices can communicate asynchronously through messaging queues like RabbitMQ, Apache Kafka, or Amazon SQS. With messaging queues, services can publish messages to a queue, and other services can consume these messages. This decouples communication between services and supports event-driven architectures.

Q. What is syncronous and asyncronous communication in microservices?
Ans:- Syncronous --> Here operations performs sequencially. First it finish one transaction then it starts another transaction.
Asyncronous --> We can perform multiple transactions paralally.

Q. What is the flow of Service Discovery?
Ans:- Service discovery in microservices is the process of dynamically locating and identifying available services within a distributed system. In a microservices architecture, where applications are composed of many small, independent services, service discovery plays a crucial role in enabling communication and collaboration between these services.

1) In microservices environment, services are often deployed across multiple instances or containers, making it challenging for clients to locate and communicate with the appropriate service instances.
2) Service discovery solves this problem by providing mechanisms for service registration, discovery, and resolution.

Q. How to handle fault tolerance using circuit breaker?
Ans:- Suppose there are three services A,B,C. A is calling to B and B is calling to C. If C is not responding then circuit breaker is used to handle the failure. We can implement retry mechanism like if a service is down then we call it twice thrice and then if that service is still not available then we can send a message that this service is not available.  

Q. SQL and No SQL database.
Ans:- In SQL database the datas are organised in a structured way. Where as in No SQL the datas are not organised in a structured way. 

Q. How to manage database schema changes?
ANs:- Design and deploy the desired schema alongside the original schema. Modify the client code to write changes to both schemas simultaneously. Migrate existing data from the original schema to the new schema, modifying it as necessary to conform to the new structure.

Q. Unique constraint in sql?
Ans:- The UNIQUE constraint ensures that all values in a column are different.


Q. Stream in Java8?
Ans:- Stream API is used to process collections of objects. A stream in Java is a sequence of objects that supports various methods which can be pipelined to produce the desired result. 

Q. Intermediate and Terminal operation in Java 8?
Ans:- Intermediate --> filter
Terminal --> for each, collect, count
The main difference between intermediate and terminal operations is that intermediate operations return a stream as a result and terminal operations return non-stream values like primitive or object or collection or may not return anything.
As the names suggest, intermediate operations doesn’t give end result. They just transform one stream to another stream. On the other hand, terminal operations give end result.

************************************************************************************************************************************************************

Q. Abstarct class in java?
Ans:- abstract classes are as follows:
1) An instance of an abstract class can not be created.
2) Constructors are allowed.
3) We can have an abstract class without any abstract method.
4) We can define static methods in an abstract class
5) If a class contains at least one abstract method then compulsory should declare a class as abstract 
6) If the Child class is unable to provide implementation to all abstract methods of the Parent class then we should declare that Child class as abstract so that the next level Child class should provide implementation to the remaining abstract method.


Q. How do you know when to use abstract class and when to use interface?
Ans:- Abstract Classes:- Use abstract classes when there is an "is-a" relationship between the base class and its subclasses. 
      Interfaces:- Use interfaces when there is no inherent "is-a" relationship, and multiple unrelated classes need to adhere to a common contract.

Q. When Finally not executed?
Ans:- When we use system.exit then finally will not execute.

Q. Difference between hashmap and hashtable?
Ans:- HashMap and HashTable are both key-value storage classes in Java. HashMap is non-synchronized, making it faster for single-threaded tasks, while HashTable is inherently synchronized, providing thread safety. 

HashTable doesn't allow any null keys or values, but HashMap lets you have one null key and several null values.

Q. Difference Between ArrayList vs LinkedList?
Ans:- ArrayList uses an array, which allows for fast random access but slow insertion and deletion. While LinkedList uses a doubly linked list, which allows for fast insertion and deletion but slow random access.

Q. Difference Between Equals And == In Java?
Ans:- 1. `equals()` method compares the content of objects, while `==` operator compares their memory addresses. 
      2. The `equals()` method can be overridden to provide customized comparison logic, whereas `==` operator cannot be overridden.

Q. How To Create an Immutable Class in Java?
Ans:- 1) Declare the class as final so it can’t be extended.
2) Make all of the fields private so that direct access is not allowed.
3) Don’t provide setter methods for variables.
4) Make all mutable fields final so that a field’s value can be assigned only once.

Q. Inversion of Control in Spring?
Ans:- Spring IoC (Inversion of Control) Container is the core of Spring Framework. It creates the objects, configures and assembles their dependencies, manages their entire life cycle. The Container uses Dependency Injection(DI) to manage the components that make up the application. It gets the information about the objects from a configuration file(XML) or Java Code or Java Annotations and Java POJO class. These objects are called Beans. Since the Controlling of Java objects and their lifecycle is not done by the developers, hence the name Inversion Of Control. 


Q. Difference between Jar and War files?
Ans:- the main difference between a JAR and a WAR file is their intended use: JAR files are used for packaging and distributing standalone Java applications or libraries, while WAR files are used for packaging and distributing web applications.

Q. Spring Profile?
Ans:- Spring Profiles provide a way to segregate parts of your application configuration and make it be available only in certain environments.
We have different environment in application like Dev, Production. So Profile is used for conditional purpose. Like for Dev we want to use a different instance of the class AND for Production environment we want to use another instance of the class.

Q. What is service discovery in microservices?
Ans:- Service discovery involves automatically discovering and locating services and devices on the network. The networking standard used is SDP (service discovery protocol), which can help clients identify resources on a network. 

Q. How services communicate with each other in microservices?
Ans:- Microservices often communicate through the HTTP protocol, which allows them to interact with each other using standard HTTP methods like 'GET, POST, PUT, and DELETE. ' This 'RESTful API' communication ensures decoupled services and platform independence.

Q. How you monitor services in microservices?
Ans:- By using Spring Admin and Actuator.

Q. What is Actuator?
Ans:- Spring Boot provides an actuator dependency that can be used to monitor and manage your Spring Boot application. First we need to add the Actuator jar (Spring boot actuator). There are multiple endpoints in actuator like status (to check the status of the microservice, like 200 for OK status), health etc. By /actuator and /actuator/health endpoints you can achieve the purpose of monitoring.


************************************************************************************************************************************************************


Q. What is Encapsulation Java?
Ans:- It is basically wrapping up data. For ex: there is a class Employee where salary is an instance and getSalary is method. We wrap up both into one single class Employee. This is Encapsulation.

Q. Why Java doesn't support multiple inheritance?
Ans:- Because of complexity java doesn't support multiple inheritance. For ex: If class A and class B have print methods, And class C extends class A and B both, then C got confused which print method to use. It becomes more complex. 

Q. Metaspace in java?   
Ans:- Metaspace is a new memory space – starting from the Java 8 version; it has replaced the older PermGen memory space. It is used to store metadata such as class definitions, method data, and field data. Unlike the heap, Metaspace is allocated out of the native memory, and its size is not fixed but can increase dynamically, which helps prevent the OutOfMemoryErrors that were possible with the Permanent Generation.

Q. What is serialization in java?
Ans:- Serialization in Java allows us to convert an Object to stream (byte stream) that we can send over the network or save it as file or store in DB for later usage. Deserialization is the process of converting Object stream to actual Java Object to be used in our program. Serialization in Java helps transport the code from one JVM to another and then de-serialize it there.

Q. How can we not make some variable (where other variables are make serializable) not serializable in java?
Ans:- You just need to make that one transient . mark the variable as transient , as Transient variables are not serialized. Sometime it is required that some field we do not want to serialize during network stream.

Q. How can we check palindrom in a string?
Ans:- We can reverse the String using String buffer and builder. Then By comparing original and reverse string we can check palindrom.

Q. Why we need to use spring framework?
Ans:- Spring is widely considered to be a secure, low-cost and flexible framework that improves coding efficiency and reduces overall application development time through efficient use of system resources. Spring removes tedious configuration work so that developers can focus on writing business logic.

Q. What is the life cycle of beans in Spring?
Ans:- The life cycle of a bean in Spring can be implemented using initialization and destruction callbacks. Developers can define methods annotated with @PostConstruct and @PreDestroy for custom initialization and cleanup tasks, ensuring proper initialization and disposal of beans managed by the Spring container.

Q. What is transactions in Spring?
Ans:- Transaction in Spring can be handled in two ways. One is Programatic way and the the other one is declarative way. In Programatic way We need to write the code for transactions to commit and for roll back of the transaction. In Declarative transaction we declare transaction in XML file, So if there is any runtime excpetion because of which we need to roll back our transaction then Spring automatically roll back the transaction.

Q. What is starter dependency in spring boot?
Ans:- Starters are a set of convenient dependency descriptors that you can include in your application. You get a one-stop-shop for all the Spring and related technology that you need, without having to hunt through sample code and copy paste loads of dependency descriptors.

Q. If I don't want to use Tomcat as server then what should I do?
Ans:- In Application.properties we can change the server from Tomcat to Jetty. Also we need to add dependency of Jetty in Pom.xml.

Q. Why we use swagger?
Ans:- Swagger allows you to describe the structure of your APIs so that machines can read them. The ability of APIs to describe their own structure is the root of all awesomeness in Swagger. Why is it so great? Well, by reading your API's structure, we can automatically build beautiful and interactive API documentation.

********************************************************************************************************************************************************

Q. What is the difference between fail-fast and failsafe?
Ans:- Iterators in Java are used to iterate over the Collection objects. Fail-Fast iterators immediately throw ConcurrentModificationException if there is a structural modification of the collection. Structural modification means adding, or removing any element from a collection while a thread is iterating over that collection. Iterator on ArrayList and HashMap classes are some examples of fail-fast Iterator.

Fail-Fast --> ConcurrentModificationException is thrown while modifying the object during the iteration process. Fail-Fast needs less memory during the process. Fail-Fast does not allow modification during the process of iteration. ArrayList, Vector, HashMap, HashSet, etc.

Fail-Safe --> No Exception is thrown. Fail-Safe iterator requires more memory during the process. Fail-Safe allows modification during the process of iteration. ConcurrentHashMap, CopyOnWriteArrayList, etc.

Q. What will happen if you use HashMap in a multithreaded Java application?
Ans:- In a multi-threaded environment, if multiple threads alter the map structurally, such as adding, removing, or modifying mappings, the internal data structure of HashMap may become corrupted and there may be some missing links, incorrect entries, and the map itself may become completely useless. Thus, you should not use HashMap in a concurrent application; instead, use ConcurrentHashMap or Hashtable which is thread-safe. The ConcurrentHashMap includes all the Hashtable’s methods as well as full concurrency of retrievals and updates.

*********************************************************************************************************************************************************

Q. Cons of Microservice?
Ans:- Management of large number of microservice is difficult. Communication between microservices is complex. Increased efforts for configuration and other opertions. Microservices will need a large team size with right mix of experience in design, development, automation, deployments, tools and testing.

Q. Is Microservice Polyglot in nature?
Ans:- Yes. Because we can use different programming language in different microservices of application. For ex: in microservice1 we can use java and in microservice2 we can use python. Also different versions of same language can also be used in different microservices.

Q. What is the difference between Monolithic, SOA(Service Oriented Architecture) and Microservice Architecture?
Ans:- Monolithic architecture is similar to a big container wherein all the software components of an application are assembled together and tightly packed.
SOA is a collection of services which communicate with each other. The communication can involve either simple data passing or it could involve two or more services coordinating some activity.
Microservice Architecture is an architectural style that structures an application as a collection of small autonomous services modeled around a business domain.
Main diff between SOA and Microservice is based on sharing of data and info. SOA shares and reuses as much as possible while microservice focuses on sharing as little as possible.

Q. How to design and implement a Microservice?
Ans:- Start with a monolith one. Then show this one to client and after getting approval make a team and organize everything. Then split the monolith one to build a Microservice Achitecture. After building the architecture make sure about things like how all microservices will communicate between each other. Then Emphasize monitoring to ease microservice testing. Always use CI/CD to make deployment process easy. 

Q. What is CI/CD?
Ans:- CI/CD, which stands for continuous integration and continuous delivery/deployment. Use CI/CD to automate your software development workflows and deploy better quality code, more often. Using a continuous and iterative process to build, test, and deploy helps avoid bugs and code failures.

Q. Provide a scenerio when you prefer Microservice over Monolithic and vice versa?
Ans:- When we prefer Microservice --- For example we are going to build a E-Commerce website. there we use microservice. Reasons are -->
a) Scalability
b) Flexibility (We can use different programming language for different microservices.
c) Team Structure
d) Development valocity
e) Complexity
f) Maintenance

When we prefer Monolithic --- For example we are going to make book review app, where user read the book and give the review. It is simple app. So to make it simple we use monolithic. Reasons are -->
a) Development speed
b) Limited Complexity
c) Resource Constraint (When we have less budget for resource)
d) Performance
e) Team size
f) Learning curve

Q. How do you make sure a microservice based application can handle more users as it become more popular?
Ans:- a) Load balancing --> for eg: suppose In Amazon, Flipkart, in normal days they have less traffic but during any sale they have more crowd. So to handle that microservice is best.
b) Auto Scaling --> It means now a days cloud based apps automatically scales instances. When more traffic in apps they give more instance to handle and when traffic starts decreasing they remove instances automatically.
c) Database Scaling 

**********************************************************************************************************************************************************

JAVA 8 Interview Questions

Q. What is Lambda expression?
Ans:- Lambda expression is introduced in Java 1.8. It is an anonymous function. It has no return type, no modifier. Lambdas are used to work with functional programming.

Q. What is Functional interface?
Ans:- It is a Single Abstruct Method interface. It contains only one abstruct method. We can write any number of default and static methods in Functional interface. We use @FunctionalInterface annotation to represent it. For example - Runnable, Callable.

Q. What is Method reference in Java 8?
Ans:- It is a shortened version of lambda expression calling a specified method. Types of method are listed below -->
   Type                           Syntex
a) Reference to static method --> ContainingClass :: static method name
b) Reference to an instance method of a particuler object --> containingObject :: InstanceMethodName                            
c) Reference to an instance method of an arbitrary object of a particuler type -->  containingType :: methodName
d) Reference to a constructor -->  classname :: new

Q. What is Optional?
Ans:- Optional is used to handle null pointer exception in Java application.

Q. Why Stream API is required?
Ans:- Stream API is sequence of elements from a source like Collection, Array which is used to perform complex operation on data. Operations like filtering, mapping, sorting etc.

Q. What is collectors in Java 8?
Ans:- Collectors is a final class in Java that extends object class. Java collectors class provides various methods to deal with elements like summarizing elements according to various criteria. Example:- stream.map().collect(Collectors.toList()).

Q. Difference between Map and Flat Map?
Ans: a) Map() method performs only mapping. Whereas flatMap() methods performs mapping as well as flattening.
 b) Mapper function produces single value for each input. Whereas Flat map produces multiple values for each input. 
 c) It is a one to one mapping. Whereas Flat map is one to many mapping. 

Q. What are the core API classes for date and time in Java 8?
Ans:- -LocalDate
      -LocalTime
      -LocalDateTime

Q. Is it possible to add a static method to an interface using Java 8?
Ans:- Yes.

Q. What is Consumer in Java 8?
Ans:- A Consumer is a single argument functional interface present in Java 8.

Q. What are the some examples of terminal operations in Java 8?
Ans:- count(), min(), max(), reduce(), toArray(), anyMatch(), allMatch().

Q. How to find and remove the duplicates using Java 8?
Ans:- By using distinct(). for example:- stream().distinct()

Q. What is easiest way to convert an array into a stream in Java 8?
Ans:- By using of() method. For example:-
  String[] test = {"hi","hello","bye"};
  Stream<String> str = Stream.of(test);
  str.forEach(System.out :: println);

Q. Difference between collection and stream?
Ans:- a) Collection is used to store and group the data in a particuler data structure. Whereas Stream is used to perform complex operations on data like filetering, mapping etc.
b) Collections have to be iterated externally. Whereas Streams have to be iterated internally.

****************************************************************************************************************************
Q. Why sometime we create a snapshot of our application.
Ans:- Speed: Snapshots capture the application's state at a specific point in time. This means you can quickly restore it without having to go through a lengthy installation or configuration process.

Consistency: Snapshots ensure that every time you restore the application, you get the exact same state, eliminating variability and potential errors.

Backup and Recovery: If something goes wrong, you can easily revert to a snapshot, ensuring minimal downtime and data loss.

Testing and Development: When developing or testing applications, snapshots can help you quickly return to a known good state after experimenting or testing new features.

Deployment: Deploying applications using snapshots can be faster and more reliable, especially in large-scale environments where consistency is key.

Q. Example of how to create snapshot of our project?
Ans:- Version Control Systems (VCS): Tools like Git can help create snapshots of your project. These are known as "commits." Each commit captures the state of your project at a specific point in time.
Initialize a Git repository in your project directory.
Use git add to stage your changes.
Use git commit to create a snapshot of your project.

****************************************************************************************************************************

Q. Diffrence between Collection snd Collections?
Ans:- Collection is an Interface. List, Set, Queue. Methods - size(), add(), remove().
Collections is a java util class. Methods - sort(), shuffle(), binarySearch().

Q. Can we print in console without using main method in java?
Ans: Yes, by using Static Blocks. Static blocks in Java are executed when the class is loaded by the JVM, before any method (like main) is invoked.

Q. Can we use multiple static block in a code. What is the use of the static block?
Ans: Yes, you can have multiple static blocks in a Java program. These blocks will execute in the order in which they are defined in the class, from top 
to bottom, when the class is loaded by the Java Virtual Machine (JVM). Static blocks are particularly helpful for organizing initialization logic.

Q. Can we have multiple finally block in java? If yes which will execute?
Ans: In Java, you cannot have multiple finally blocks associated with a single try block.

Q. Can we include class a key in hashmap?
Ans: In hashMap we use always immutable objects(we use wrapper class object). Class is mutable object. Nut we can use class as a key in hasmap by overriding 
hashcode() and equals() method.

Q. Reflection in java?
Ans: Reflection in Java is a powerful feature that allows you to inspect and manipulate the runtime behavior of classes, methods, fields, and constructors. 
It provides the ability to dynamically access and modify code during execution, which is especially useful for tasks like debugging, testing, and building 
frameworks.

Q. Can functional interface can extend another interface?
Ans: Yes, a functional interface in Java can extend another interface(which has static and default method), including other functional interfaces. 
For Example:
@FunctionalInterface
interface ParentInterface {
    void method1();
}

@FunctionalInterface
interface ChildInterface extends ParentInterface {
    // No need to declare method1() again, it inherits from ParentInterface
}



Q. Scope of bin in Spring?
Ans: Two types : 1) Singleton - Creates one instance only for the entire spring container
2) Prototype - creates every time new instance.
For HTTP request we REQUEST and SESSION scope as well.

Q. How to implement caching in spring boot application?
Ans: By giving cache dependency in pom.xml.
Use the @EnableCaching annotation in your main application class to enable caching functionality.
Apply the @Cacheable annotation on methods whose return values you want to cache. The annotation specifies the cache name.

Q. What methods use when send duplicate request and it doesn't affect the server?
Ans: To ensure that duplicate requests don't adversely affect the server, you can use idempotent methods.
Idempotent HTTP Methods:- GET(Retrieve data), PUT(Modidfy), DELETE(Remove).

Q. Difference between RequestParam and pathVariable?
Ans: @RequestParam is used to extract query parameters from the URL in key value pair.
Example: For the URL: http://localhost:8080/api?name=John
@GetMapping("/api")
public String getData(@RequestParam String name) {
    return "Hello, " + name;
}
Output: "Hello, John".

PathVariable is used to extract values from the URI path.
Example: For the URL: http://localhost:8080/api/John
@GetMapping("/api/{name}")
public String getData(@PathVariable String name) {
    return "Hello, " + name;
}
Output: "Hello, John"


Q. @Configuration annotation?
Ans: It is used to define configuration classes that provide bean definitions for the application context.It is
responsible for creating and returning instances of objects (beans).


Q. Desing pattern in spring?
Ans: Spring Framework incorporates various design patterns to promote flexibility, scalability, and maintainability in application development.
1. Dependency Injection Pattern (Creational Pattern)
What It Does: Decouples the creation of an object from its usage, allowing the object to be injected into a class instead of the class instantiating it.
2. Singleton Pattern (Creational Pattern)
What It Does: Ensures that only one instance of a class is created and shared throughout the application.

***************************************************************************************************************************

Q. Difference between inheritance and interface with project real time example.
Ans: Inheritance allows a class (subclass) to derive properties and behaviors from another class (superclass). It promotes code reuse and enables the 
subclass to inherit fields and methods from the parent class.
An interface defines a contract or blueprint that classes must follow. It specifies what methods a class must implement but does not provide the 
implementation itself.


Q. What is use of finnaly block?
Ans: The finally block in Java (and many other programming languages) is used to ensure that a specific section of code is always executed, regardless 
of whether an exception is thrown or caught in the try block. It's often used for cleanup operations, such as closing resources (files, database 
connections, sockets, etc.) or releasing memory. 


Q. If you don't close the connection in final block then what will happen? Is there any memory leak if don't close it?
Ans: If a connection (such as a database connection or file stream) is not closed, it can lead to resource leaks and potentially cause a memory leak 
depending on how the underlying system handles resources.


Q. What is collection?
Ans: collection is a framework that provides an architecture to store, manage, and manipulate a group of objects. It is part of the Java Collections 
Framework (JCF), which includes interfaces, classes, and algorithms to handle data structures like lists, sets, queues, and maps.


Q. Difference between collection and collections?
Ans: Collection (Interface):
Definition: Collection is a root interface in the Java Collections Framework. It defines the basic methods for working with a group of objects 
(e.g., adding, removing, and iterating elements).
Belongs To: java.util package.
Hierarchy: Subinterfaces of Collection include List, Set, and Queue.
It provides methods like add(), remove(), size(), iterator(), etc.

Collections (Class):
Definition: Collections is a utility class in the Java Collections Framework. It provides static methods to operate on or return collections, such 
as sorting, searching, and thread-safe wrappers.
Belongs To: java.util package.
Purpose: Provides utility methods for easier manipulation of collections like List, Set, and Map.


Q. Difference between linkedlist and arraylist?
Ans: In LinkedList it is easy to insert or remove elements. But in ArrrayList if not easy.
In LinkedList accessing element is slow. But in ArrayList accessing element is fast.


Q. So you implement HashPosition isn your project and how?
Ans: No.


Q. What is the use of profiles in spring boot?
Ans: This is particularly useful for handling deployment in development, testing, staging, and production environments.


Q. What type of Spring dev tools used and worked on?
Ans: Spring DevTools is a popular module provided by Spring Boot to improve development productivity. It helps developers create, test, and debug 
Spring applications more efficiently. DevTools automatically restarts your application whenever code changes are detected, saving time compared to 
manually restarting. It uses a class loader to reload changes without restarting the entire JVM.


Q. Different types of Autowiring?
Ans: 1. Default (No) - Manual Definition
2. byName - Matches property name with bean name 
3.byType - Matches property type with bean type 
4. Constructor- Matches constructor arguments with bean types
5. Autowired - By type or by qualifier


Q. How to handle exceptions in Spring boot?
Ans: 1. You can define custom methods within a controller to handle specific exceptions using the @ExceptionHandler annotation.
2. To manage exceptions across the entire application, use @ControllerAdvice. It centralizes exception handling for multiple controllers. 
@RestControllerAdvice manages all exceptions for the application.
3. Custom exceptions add clarity and meaning to your application’s error handling. (public class ResourceNotFoundException extends RuntimeException)


Q. What is the difference between SQL and HQL?
Ans: SQL: A standard query language used to interact with relational databases (e.g., MySQL, PostgreSQL, Oracle).
Focuses on directly querying database tables and manipulating their data.

HQL:A query language used in Hibernate (an ORM framework) for interacting with objects mapped to database tables.
Operates at the object-oriented level, querying entities rather than directly working with tables.


Q. How do you map java application into database?
Ans: Mapping a Java application to a database involves connecting your application to the database and managing the interaction between Java objects 
and database tables. This is typically achieved using Object-Relational Mapping (ORM) tools like Hibernate, JPA (Java Persistence API), or frameworks 
like Spring Data JPA.


Q. Types of mapping. OneToOne, ManyToOne, ManyToMany, OneToMany?
Ans: 1. One-To-One Mapping
Definition: A relationship where one entity is associated with exactly one other entity.
Use Case: Linking entities like User and Profile, where each user has exactly one profile, and each profile belongs to one user.
2. One-To-Many Mapping
Definition: A relationship where one entity is associated with multiple instances of another entity.
Use Case: A Department having multiple Employees.
3. Many-To-One Mapping
Definition: A relationship where many entities are associated with a single instance of another entity.
Use Case: Employees belonging to a single Department.
4. Many-To-Many Mapping
Definition: A relationship where many entities are associated with many other entities.
Use Case: Students enrolling in multiple Courses, and Courses having multiple Students.


Q. What is the transaction management in hibernate?
Ans: Transaction management in Hibernate is a crucial aspect that ensures the consistency and integrity of data in a relational database. 
It involves coordinating the sequence of operations (like saving, updating, or deleting data) within a unit of work, ensuring they either all 
succeed (commit) or all fail (rollback).

Key Concepts in Transaction Management
ACID Properties:Hibernate transactions adhere to the ACID principles:
Atomicity:- All operations in the transaction are treated as a single unit. Either all succeed or none.
Consistency:- The database remains in a valid state after the transaction.
Isolation:- Transactions are isolated from one another, preventing conflicts.
Durability:- Changes made by committed transactions are permanently saved.

Transaction Lifecycle:
Begin:- The transaction starts and locks resources.
Commit:- Changes are applied to the database.
Rollback:- If something goes wrong, all changes are undone, and the database is restored to its previous state.

Transaction Management with Hibernate:-
beginTransaction() starts a transaction.
commit() saves changes permanently.
rollback() reverts changes if an error occurs.

Using JPA with Spring Transaction Management:-
Use the @Transactional annotation for automatic transaction handling.


Q. What is dependency injection and how it helps in bean life cycle?
Ans: Dependency Injection (DI) is a design pattern widely used in frameworks like Spring to manage the lifecycle of objects (often referred to as "beans"). 
It allows the injection of dependencies into an object, rather than the object itself being responsible for instantiating or managing those dependencies. 
This is particularly useful for creating loosely coupled and testable applications.

It helps in bean life cycle by decoupling your bean creation and configuration.

*****************************************************************************************************************************


Q. Difference between creating String with literal and new operators
Ans: 1. Using String Literal: -
When you create a String using a literal (e.g., String str1 = "Hello";), the JVM checks the String Pool (a part of the heap memory) to see if an equivalent 
String already exists.
If it does, the new variable references the existing String object.
If not, a new String object is created in the pool, and the variable references it.
Advantages: This approach is memory-efficient, as duplicate String objects are avoided.

2. Using new Operator: -
When you create a String using the new operator (e.g., String str2 = new String("Hello");), a new String object is created in the heap memory, even if an 
equivalent String exists in the String Pool.
This means it bypasses the String Pool and explicitly allocates new memory for the object.
Drawback: It is less efficient as it can lead to duplicate String objects in memory.


Q. What is String Pool? How it is working? 
Ans: The String Pool is a special storage area in Java's heap memory where String literals are stored. Its purpose is to optimize memory usage and 
improve performance by preventing the creation of duplicate String objects.


Q. Advantages of String Pool?
Ans: Advantages of the String Pool:
1. Memory Efficiency
2. Performance Boost
3. Thread Safety
4. Automatic Deduplication


Q. Why String is Immutable class? 
Ans: Immutability in Java String means once a String object is created, its value cannot be changed. Here's why:

1. Security: Immutability helps protect sensitive data like database connection URLs, passwords, or keys passed as strings. Since the value cannot 
change, it ensures consistent and secure handling.

2. String Pool Compatibility: Immutability allows strings to be safely stored and reused in the String Pool. If strings were mutable, changes to one 
reference would unexpectedly affect others sharing the same object.

3. Caching and Optimization: Internally, strings are often used as keys for hash-based structures like HashMap or HashSet. Immutability guarantees 
that the hashCode and value of a string cannot change, making it efficient and reliable as a key.

4. Thread Safety: Immutability ensures that strings are inherently thread-safe, meaning multiple threads can use them 
without synchronization or race conditions.


Q. What are the use cases of creating User Defined Exceptions. 
Ans: User-defined exceptions in Java are custom exceptions created by developers to handle specific scenarios that built-in exceptions cannot address 
effectively. Here are some common use cases for creating user-defined exceptions:

Domain-Specific Validation: When dealing with application-specific rules or constraints, user-defined exceptions help enforce these rules. Example: 
Throwing a InvalidAgeException when the age entered does not meet the required criteria.


Q. How to handle User Defined Exceptions?  
Ans: Steps to Handle User-Defined Exceptions
1. Create the Exception Class -
Define your custom exception by extending the Exception class or RuntimeException class.
2. Throw the Exception -
Use the throw keyword to raise the exception when the specific condition occurs.
3. Catch the Exception -
Use a try-catch block in your code to catch the exception and handle it gracefully.

Q. throw v/s throws functionality?
Ans: throw Keyword:
Purpose: Used to explicitly throw an exception during the execution of a program.
Usage: Typically inside a method or block to indicate that something has gone wrong.
Behavior: After an exception is thrown using throw, the program flow is interrupted, and the exception must be caught or propagated.
Syntax: Requires an instance of the Throwable class (e.g., Exception or Error) to be thrown.
Only one exception can be thrown at a time.

throws Keyword:
Purpose: Declares that a method may throw one or more exceptions. It informs the caller of the method that exceptions need to be 
handled or propagated further.
Usage: Added to the method signature, specifying the exception types the method might throw.
Behavior: By using throws, the method signals that it does not handle the exception internally, leaving it for the caller to handle.


Q. What is Stream API? Advantages of Stream API?
Ans: The Stream API in Java is a powerful feature introduced in Java 8. It is primarily used for processing sequences of data in a 
functional and declarative style, allowing developers to perform operations like filtering, mapping, and reducing data in collections or arrays.
 
Advantages: - Streams enable efficient, readable, and concise code for bulk operations.


Q. What is Stream Pipeline? 
Ans: A Stream Pipeline in Java is the sequence of operations performed on a stream to process data. 
It is composed of three main elements: a source, intermediate operations, and a terminal operation. The pipeline allows developers to process 
collections, arrays, or other data sources in a functional and declarative style.


Q. Intermediate v/s Terminal Operators Using Stream API?
Ans:  Intermediate Operations: These operations transform or filter the stream's elements. They are lazy (not executed until a terminal operation 
is called). Intermediate operations can be chained together to build the pipeline. Examples:
filter(Predicate), map(Function), sorted(Comparator), distinct()

Terminal Operation: The final operation that triggers the execution of the stream pipeline and produces a result or a side effect. Examples:
collect(Collector), forEach(Consumer), count(), reduce(BinaryOperator)


Q. Find 2nd highest salary from given Employee Objects List Using Stream API? 
Ans: //FIND SECOND SMALLEST AND LARGEST
        Integer secSmall = list.stream().distinct().sorted().skip(1).findFirst().orElse(null);
        Integer secLargest = list.stream().distinct().sorted((i1,i2)->i2.compareTo(i1)).skip(1).findFirst().orElse(null);


Q. Find female employes count from given Employee Objects List.
Ans:
public class Employee {
    private String name;
    private String gender;

    // Constructor
    public Employee(String name, String gender) {
        this.name = name;
        this.gender = gender;
    }

    // Getter for gender
    public String getGender() {
        return gender;
    }

    public static void main(String[] args) {
        // List of employees
        List<Employee> employees = Arrays.asList(
            new Employee("Alice", "Female"),
            new Employee("Bob", "Male"),
            new Employee("Cathy", "Female"),
            new Employee("David", "Male")
        );

        // Count female employees using Stream API
        long femaleCount = employees.stream()
                                    .filter(emp -> emp.getGender().equalsIgnoreCase("Female"))
                                    .count();

        System.out.println("Number of female employees: " + femaleCount);
    }
}

  
Q. What is @Qualifier annotation 
Ans: The @Qualifier annotation in Spring Framework is used to resolve the ambiguity that arises when multiple beans of the same type are eligible 
for dependency injection. By using @Qualifier, you can specify the exact bean you want to inject into a field, constructor, or method.
For example: 
@Bean
public Service service1() {
    return new Service();
}

@Bean
public Service service2() {
    return new Service();
}

@Component
public class Client {
    private final Service service;

    @Autowired
    public Client(@Qualifier("service1") Service service) {
        this.service = service;
    }
}


Q. What is @SpringBootApplication?
Ans: The @SpringBootApplication annotation is a key annotation in Spring Boot that serves as a convenient shortcut for enabling various configurations 
needed to bootstrap a Spring Boot application. It combines three commonly used Spring annotations into one:
@Configuration
@EnableAutoConfiguration
@ComponentScan


Q. How to avoid Bean Creation Failures in Dependency Injection?
Ans:  Avoiding bean creation failures in dependency injection requires careful design, configuration, and handling of Spring beans to ensure that 
dependencies are properly resolved. Below are some strategies and best practices to prevent such issues:

1. Properly Define Bean Names
Ensure that beans have unique names to avoid ambiguity during dependency injection.
Use the @Qualifier annotation when multiple beans of the same type exist to specify the exact bean to inject.


Q. What is ORM? 
Ans: ORM (Object-Relational Mapping) is a programming technique used to simplify the interaction between object-oriented programming languages 
and relational databases. It allows developers to map database tables to Java objects (or objects in other languages) and vice versa, enabling seamless 
data manipulation without the need for extensive SQL queries.


Q. What is REST API and advantages of REST API Process for Creating REST API and an example?
Ans: REST API stands for Representational State Transfer Application Programming Interface. It is a set of rules and conventions for building and 
interacting with web services. REST APIs use HTTP methods (like GET, POST, PUT, DELETE) to enable communication between a client and a server. The key 
principle of REST APIs is statelessness, meaning that each request contains all the information necessary for the server to process it, without relying 
on stored context.

Advantages of REST APIs: -
1. Scalability: REST APIs are stateless, which makes them scalable as server-side state management isn't required.
2. Simplicity: REST APIs use standard HTTP methods, making them easy to understand and use. They leverage uniform resource identifiers (URIs) for 
identifying resources.
3.Flexibility: REST APIs can support multiple data formats (e.g., JSON, XML) for communication, making them adaptable to various client needs.


Q. What is Producer and Consumer Applications?
Ans: A producer is an application or component responsible for creating and sending data (or messages) to a shared resource, such as a message 
queue, database, or other intermediary. It generates data to be consumed by other applications or services.
Example Use Cases:
An IoT device collecting temperature data and sending it to a server.
A web application sending user activity logs to a logging system.

Consumer Application: -
A consumer is an application or component responsible for receiving and processing data created by the producer. It subscribes to the shared 
resource (e.g., a message queue) and consumes the data when it's available.
Example Use Cases:
A data analytics tool processing logs from a logging system.
An email service consuming messages from a queue and sending notifications.
A database updater consuming stock prices for real-time updates.

-------------------------------------------------------------------------------------------------------------------------------------------------------------
Caching - in memory storage. Redis is one of a caching technique. In heibernet two types of caching. One is session level caching(different caching for for every session) and other one 
is session factory caching(same caching for all sessions. And this is singleton).  How to apply caching in your app?


Q. GraphQL?
Ans: GraphQL is a modern query language for APIs that allows clients to request exactly the data they need, making it more efficient and flexible than traditional REST APIs.

Q. RestTemplate?
Ans: RestTemplate is a Spring Framework class used to make HTTP requests to RESTful web services from a Java application. It simplifies client-side HTTP communication 
by abstracting away the boilerplate code needed to send requests and handle responses.

Q. Pagination?
Ans: Pagination is the process of dividing a large set of data into smaller, manageable chunks (pages), typically used in web applications to improve performance and user experience 
when displaying lists of items like search results, products, or database records
Kubernetes Orchestration?

Q. Transactional?
Ans: In Java and Spring, transactional refers to executing a block of code (usually database operations) as a single unit of work that either completes entirely or rolls 
back completely if any part fails. This ensures data consistency and integrity.
A transaction is a sequence of operations performed as a single logical unit. It must follow the ACID properties:
Atomicity: All operations succeed or none do.
Consistency: Data remains valid before and after the transaction.
Isolation: Transactions don’t interfere with each other.
Durability: Changes persist even after system failure.


Q. How you optimize query in hibernate or any database?
Ans: Use indexing. It will reduce the load in backand and while fatching the data it will be helpful.

Q. Why we use packages in java?
Ans: A package is a namespace that groups related classes and interfaces together. Packages in Java are used to organize related classes and interfaces, prevent naming conflicts, and 
improve code maintainability and access control.


Q. what if two packages has same class name?
Ans: We can import the package with class name. For example
import com.company.sales.Customer   OR com.company.sales.*
import com.company.support.Customer  OR com.company.support.*

Q. Can static block means static class or method throw exception in java?
Ans: es, static methods behave like any other method. They can throw both checked(ou must handle them with a try-catch block. ex: IO Exception) and unchecked exceptions(ex: Runtime 
exception).


Q.Can you override static method in java?
Ans: No. Because Static methods belong to the class, not to instances of the class.

Q. Generics in java?
Ans: Generics in Java allow you to write flexible, reusable, and type-safe code by using parameterized types like <T>. They help avoid runtime errors and reduce the need for casting.

Q. Can we use generics in array?
Ans: Using generics with arrays in Java is possible but comes with important limitations due to how Java handles type erasure and array covariance.

Q. What happens when an exception is thrown in a static initialization block?
Ans: When an exception is thrown in a static initialization block and not caught, the class fails to initialize properly, and the Java Virtual Machine (JVM) throws an 
ExceptionInInitializerError.


Q. Can we throw exception in finally block?
Ans: Yes, you can throw an exception in a finally block in Java. For Ex:
	public static void main(String[] args) {
        try {
            throw new RuntimeException("From try");
        } finally {
            throw new RuntimeException("From finally");
        }
    	}


Q. Can we determine method overloading in run time?
Ans: No, method overloading in Java is determined at compile time, not at runtime.

Q. Real time example of using final keyword?
Ans: public class Finance {
    public static final double TAX_RATE = 0.18;

    public double calculateTax(double amount) {
        return amount * TAX_RATE;
    }
}

Q. Inner classes in Java?
Ans: Inner classes in Java are classes defined within another class or interface, used to logically group code, enhance encapsulation, and improve readability.

Q. What is java memory model?
Ans: The Java Memory Model (JMM) defines how threads interact through memory and ensures consistent behavior in concurrent programming by specifying rules for visibility, 
ordering, and atomicity of shared variables.

Q. How you investigate memory leak in java?
Ans: To investigate a memory leak in Java, you typically analyze heap usage, identify objects that aren’t being garbage collected, and trace their references using 
profiling tools like VisualVM, Eclipse MAT, or JProfiler. 

Q.Design pattern in java.
Ans: Design patterns in Java are proven solutions to common software design problems, helping developers write flexible, reusable, and maintainable code. They are categorized 
into creational, structural, and behavioral patterns.

Pattern		Purpose
Singleton		Ensures only one instance of a class exists.
Factory		Creates objects without exposing instantiation logic.
Abstract Factory	Produces families of related objects.
Builder		Constructs complex objects step-by-step.
Prototype		Clones existing objects instead of creating new ones.


Q. Autoconfigure in spring boot?
Ans: Auto-configuration in Spring Boot automatically configures your application based on the dependencies and settings present, reducing the need for manual setup.

Q. Steps to integrate database in spring boot from scratch?
Ans: 1. Add Database Dependency in pom.xml or build.gradle
2. Configure Database in application.properties or application.yml
3. Create Entity Class
4. Create Repository Interface
5. Create Service and Controller


Q. How will you secure spring boot app?
Ans: 1. Add Spring Security Dependency
2. Basic Authentication (Default)
Spring Boot auto-secures all endpoints with HTTP Basic authentication. A default user and password are generated unless overridden in application.properties:
	spring.security.user.name=admin
	spring.security.user.password=secret
3. Custom Security Configuration
Create a class that extends WebSecurityConfigurerAdapter (Spring Boot 2.x) or use SecurityFilterChain bean (Spring Boot 3.x)
4. User Details and Roles
Define users and roles either in-memory or via a database:

public UserDetailsService userDetailsService() {
    UserDetails user = User.withDefaultPasswordEncoder()
        .username("user")
        .password("password")
        .roles("USER")
        .build();
    return new InMemoryUserDetailsManager(user);
}
5. Protect Against CSRF
Spring Security enables CSRF protection by default. For stateless APIs, you may disable it:
http.csrf().disable();
6. Secure REST APIs
Use JWT (JSON Web Tokens) for stateless authentication:
Generate token on login
Validate token on each request
Use filters to intercept and verify tokens
7. HTTPS and Headers
Enforce HTTPS using http.requiresChannel().anyRequest().requiresSecure()
Set security headers: http.headers().xssProtection().and().contentSecurityPolicy("script-src 'self'")

Q. Difference between authorization and authentication?
Ans: 
Feature		Authentication						Authorization
Definition		Verifying who the user is				Determining what the user can access
Purpose		Confirms identity						Grants or denies permissions
Occurs When		Before authorization					After successful authentication
Example		Logging in with username and password		Accessing admin dashboard based on user role


Q. How can you secure methods in class?
Ans: To secure methods in a class in a Spring Boot application, you can use method-level security annotations provided by Spring Security.
1. Enable Method Security
Add this to your configuration class:

@EnableMethodSecurity  // Spring Boot 3.x
// or
@EnableGlobalMethodSecurity(prePostEnabled = true)  // Spring Boot 2.x

2. Use Security Annotations on Methods
Annotation			Purpose
@PreAuthorize		Checks before method execution
@PostAuthorize		Checks after method execution
@Secured			Restricts access based on roles
@RolesAllowed		Similar to @Secured, uses JSR-250

*************************************************************************************************************************************************

Q. Types of communication in microservice?
Ans. Two types:
Synchronous - Uses Rest template
Asynchronous - Uses Kafka, RabitMq

Q. What are features you used in API Gateway in your project?
Ans: First we add Authentication and Authorization.
Second Rate Limiting - It used to limit the rate means if there are so many requests coming but we can't handle more requests so we limit rate and status we kept as 429. 


Q. In java8 we have 2 interfaces and both intefaces have same default method. Now the class is implementing both intefaces. So how jvm will know which method to call?
Ans: In Java 8, interfaces can have default methods—methods with a body. If a class implements two interfaces that define the same default method, the compiler will 
throw an error unless you explicitly resolve the conflict. Use IntefaceName.super.MethodName(). Example code below -

interface A {
    default void greet() {
        System.out.println("Hello from A");
    }
}

interface B {
    default void greet() {
        System.out.println("Hello from B");
    }
}

class C implements A, B {
    @Override
    public void greet() {
        // You must resolve the conflict explicitly
        A.super.greet();  // or B.super.greet()
    }
}


Q. Why private method is introduced in interface?
Ans: Private methods were introduced in Java 9 interfaces to improve code modularity, reusability, and encapsulation within interfaces—especially when using default and static methods. Private methods in interfaces: Can be used only within the interface, Cannot be called by implementing classes, Can be private or private static. Example - 

interface Logger {
    default void logInfo(String message) {
        log("INFO", message);
    }

    default void logError(String message) {
        log("ERROR", message);
    }

    private void log(String level, String message) {
        System.out.println(level + ": " + message);
    }
}

Here, log() is a private helper method used by both logInfo() and logError(), but it’s not accessible to classes implementing Logger.


Q. When to use default method and when to use static method in java 8?
Ans: 
Feature			default Method			static Method
Tied to object?		Yes (can be overridden)		No (called via interface name)
Access			Through instance			Through interface name
Overrideable?		Yes					No


Q. What is variable argument?
Ans: Variable arguments (varargs) in Java allow a method to accept zero or more arguments of a specified type. This is useful when you don’t know in advance how many arguments 
will be passed. Example - 

public void printNames(String... names) {
    for (String name : names) {
        System.out.println(name);
    }
}

String... names means the method can take any number of String arguments.
Internally, Java treats names as an array: String[] names.
Only one varargs parameter is allowed per method.
It must be the last parameter in the method signature.


Q. What is equals and hashcode contract?
Ans: The equals() and hashCode() contract in Java defines how these two methods must behave together to ensure consistent and predictable behavior—especially when objects 
are stored in hash-based collections like HashMap, HashSet, or Hashtable.
Consistency Between equals() and hashCode() - 
If two objects are equal according to equals(), they must have the same hashCode().
If two objects have different hashCode() values, they are not equal.
If two objects have the same hashCode(), they might be equal—but not necessarily.



Q. What is the difference between base class and abstract class?
Ans: A base class is a general term for any class that is extended or inherited by another class.
Can be concrete (fully implemented) or abstract. Provides common functionality to derived classes.

An abstract class is a special kind of base class that cannot be instantiated directly and may contain abstract methods (methods without implementation).
Declared with the abstract keyword. Can have abstract and non-abstract methods. Used to define a template or blueprint for subclasses.
Must be extended by another class that provides implementations for abstract methods. Example - 

abstract class Shape {
    abstract double area(); // abstract method
    void display() {
        System.out.println("Displaying shape...");
    }
}
class Circle extends Shape {
    double area() {
        return Math.PI * 5 * 5;
    }
}


Q. When we are using marker interface?
Ans: A marker interface in Java is an interface that contains no methods or fields—it's used purely to mark or tag a class with metadata that can be recognized by the JVM or frameworks. Example - 

public interface Serializable {}

When a class implements Serializable, it tells the JVM that its objects can be converted into a byte stream.


Q. What is volatile veriable?
Ans: A volatile variable in Java is a special kind of variable used in multithreaded programming to ensure visibility of changes across threads.

What Does volatile Do?
When a variable is declared as volatile, it tells the Java Virtual Machine (JVM):
“This variable might be modified by multiple threads—always read it directly from main memory, not from a thread’s local cache.”


Q.Can we write funvtional interface without abstract method?
Ans: No, you cannot write a functional interface without an abstract method—because by definition, a functional interface must have exactly one abstract method.

Q. Suppose we have one TreeSet and it has two values, one is null and another one is some object lets say abc. Now we want to print the TreeSet. What will be the output?
Ans: If you try to add both null and a non-null object like "abc" to a TreeSet in Java, you’ll get a NullPointerException at runtime.

Q. If we give System.exit() in try catch block, Will finally execute after that also?
Ans: No, the finally block will not execute if you call System.exit() inside the try or catch block.

Q. What is fault isolation?
Ans: Fault isolation is the practice of containing errors within a specific component or service so they don’t affect the entire system.Fault isolation ensures that when one part of a system fails, the failure is localized and does not cascade to other parts. This makes systems more robust, easier to debug, and safer to operate.


Q. How to handle exceptions globally in spring boot?
Ans: To handle exceptions globally in Spring Boot, use @ControllerAdvice(in class name) combined with @ExceptionHandler(in method signature). This allows you to centralize error handling across all controllers and return consistent, structured responses.


Q. What is the default scope in maven?
Ans: In Maven, the default scope for dependencies is compile.


Q. What is Maven plugin?
Ans: A Maven plugin is a reusable unit of work that performs specific tasks during the build lifecycle of a Maven project. Plugins are the backbone of Maven—they execute goals like compiling code, running tests, packaging artifacts, and deploying applications. (e.g., compile, test, package, install).

******************************************************************************************************************************************************************

Microservice Questions
Q. What are microservices?
Ans: Microservices are an architechtural style where an application is built as a collection of small, independent, and loosly coupled servoces.
  
Q. What are key features of microservices?
Ans: Independent deployment - we can deploy each microservice independently.
Fault tolarance - If one service is down, it won't affect other services.
Scalability - We can scalable every microservices independently.

Q. Main components of microservices?
Ans: Api gateway, load balancer, data management, monitoring and logging(grafana), CI/CD pipeline.

Q. What is the role of API gateway?
Ans: An api gateway serves as a centralized entry point for managing client interactions with microservices. It helps in load balancing. It evenly distributes loads with all the 
instance of a microservice. Also it checks for authorization. 

Q. What is service discovery?
Ans: It is a mechanism that enables microservices to dynamically locate and communicate with other services without hardcoded configurations, promoting flexibility.

Q. What is container and why it used in microservices?
Ans: A container is a standalone unit that bundles an application with its dependencies, including libraries, configurations and runtime.
Advantage of container is continuous deployment. Other advantage is faster startup time. Containers are more light weight and have faster initialization, thereby enabling 
quicker deployment and scalability.

Q. How you handle failures in microservices?
Ans: Circuit breaker.

Q. What is OAuth?
Ans: OAuth stands for open authorization. It is an open standard protocol that allows third party applications to access a user's resources without exposing their credentials such
as passwords, username.

Q. What is CQRS pattern in microservices?
Ans: CQRS, or Command Query Responsibility Segregation, is a software design pattern that separates a system's read and write operations into distinct models. A command is an
operation that changes state (like create, update, delete), while a query retrieves data without changing it. By segregating these functions, CQRS allows for independent 
optimization, which improves performance, scalability, and security, especially in complex apploications.

Q. How do you ensure security in microservices?
Ans: Secure communication - add encryption so that the communication between services will be encrypted.
Authentication and authorization
Service level isolation - Here we restrict the access between the services to only necessary parts. This ensures services will interact only required things.

Q. What is event driven architecture in microservices?
Ans: It is a design pattern where microservices communicate with each other by producing and consuming events rather than making direct api calls.

Q. What is Idempotency and why it is important in microservices?
Ans: It ensures making the same request multiple times produces the same result, regardless how many time it is executed. In microservices sometimes it is common for
the requests to be retry either by the client or by the services. Without Idempotency it leads to undesirable results such as duplicate records.


Q. What is database sharding?
Ans: It is a technique where large datasets are divided into smaller, more manageable pieces called "shards". In microsevice it is helpful as every service can have their 
own database.

Q.What is Canary deployment?
Ans: It is a software release strategy where new version of a service is gradually introduced to a small subset of users before a full rollout to the entire database.

Q. How would you monitor microservices?
Ans: Distributed tracing: with this you track the flow of requests. Which helps in identify performance and finding root cause for errors.
Metric Collection: It collects the key performance indicators such as response time, throuput, cpu usage.
Visualization and alerting: Here you visualize collected metrics and tracing data using dashboards and creates alert to notify.

Q. How do you design for scalability in microservices?
Ans: Horizontal scalling: Increasing instance of a service to handle more load.
Data partitioning (Sharding)
Caching: storing frequently access data to reduce the load on the underlying database.
Load balancing.

Q. What is Chaos Engineering?
Ans: Chaos Engineering is intesionally introducing controlled failure to test the services resilience and fault tolerance.

Q. What are sidecars in Microservices?
Ans: It is a design pattern where a lightweight container runs along side the main application container within the same deployment unit. Uses are monitoring and logging.
And network traffic management. And security. 


***********************************************************************************************************************************************************

Q. What Is @SpringBootApplication?
Ans: @SpringBootApplication is a meta-annotation that combines three core Spring annotations:
@Configuration: Marks the class as a source of bean definitions.
@EnableAutoConfiguration: Enables Spring Boot’s auto-configuration mechanism.
@ComponentScan: Scans the package for Spring components like @Service, @Repository, and @Controller.


Q. What is the issue if we use transactional in class or method level?
Ans: Using @Transactional at the class level applies the transaction to all public methods, while using it at the method level gives you fine-grained control. However, 
class-level usage can lead to unintended behavior, especially with internal method calls and exception handling.


Q. What is compansating transaction and distributed transaction?
Ans: A distributed transaction is a single transaction that spans multiple independent systems or databases, ensuring atomicity across all of them.
Example: A banking app transfers money from Account A (in Service X) to Account B (in Service Y). Both services must commit or rollback together.

A compensating transaction is a manual rollback mechanism used when a distributed transaction fails. Instead of rolling back automatically, you undo the effects of previous 
successful steps.


Q. Endpoints in actuator in spring boot?
Ans: 
Endpoint			Description
/actuator/health		Shows application health status (e.g., UP, DOWN)
/actuator/info		Displays arbitrary application info (e.g., version, description)
/actuator/metrics		Exposes metrics like memory, CPU, GC, HTTP requests
/actuator/env		Shows environment properties (system, application, etc.)


Q. How JPA helps?
Ans: JPA acts as a bridge between Java objects and database tables, enabling object-relational mapping (ORM). It abstracts the persistence layer, making it easier to 
perform CRUD operations, manage relationships, and handle transactions.
Key Benefits of JPA
Object-Relational Mapping (ORM): Maps Java classes to database tables and fields to columns.
Reduces Boilerplate Code: Eliminates repetitive SQL and JDBC code.

Q. Suppose you have a requirement to dynamically fetch data with variable search criteria. How would you do that?
Ans: 1. Spring Data JPA Query Methods
Use method naming conventions to define queries:
List<User> findByNameAndAge(String name, int age);

2. @Query with JPQL or Native SQL
Write custom queries:
@Query("SELECT u FROM User u WHERE u.name = :name OR u.age = :age")
List<User> search(@Param("name") String name, @Param("age") int age);


Q. When we use custom query where we don't have option to use default query?
Ans: We typically use custom queries in Spring Data JPA when default query methods (like findByName, findByEmailAndStatus, etc.) are not sufficient to express the desired 
logic.

1. Complex Conditions
Default method naming becomes unreadable or impossible:
@Query("SELECT u FROM User u WHERE u.age > :age AND u.status = :status")
List<User> findActiveUsersOlderThan(@Param("age") int age, @Param("status") String status);

2. Joins Across Entities
When you need to join multiple tables/entities:
@Query("SELECT o FROM Order o JOIN o.customer c WHERE c.name = :name")
List<Order> findOrdersByCustomerName(@Param("name") String name);

3. Aggregations or Grouping
For queries involving COUNT, SUM, GROUP BY, etc.:
@Query("SELECT c.name, COUNT(o) FROM Customer c JOIN c.orders o GROUP BY c.name")
List<Object[]> countOrdersByCustomer();


Q. What is Spring data JPA repository? And what are the disadvantages of it?
Ans: Spring Data JPA Repository is an abstraction layer that simplifies data access in Spring applications by automatically generating queries and CRUD operations for 
JPA entities.
Disadvantages: Naming conventions for query methods which can be confusing and limited for complex queries. Custom implementation must be necessary for advance query.

Q. Give example where == gives true and .equals() gives false?
Ans: string s1="hi" 
String s2="hi" 
String s3=new String("hi") 
s1==s2 True 
s1.equals(s2) True 
s1==s3 False
s1.equals(s3) True //As content is same.


Q. hat happens if two hashmap key has same hashcode?
Ans: If two keys in a Java HashMap have the same hash code, the map handles it using a technique called collision resolution.

What Happens Internally
Hash Code Calculation:
Each key's hashCode() is computed.
If two keys return the same hash code, they are mapped to the same bucket in the internal array.

Collision Handling:
Java uses chaining to resolve collisions.
The bucket becomes a linked list (or a balanced tree if many collisions occur).
The map stores both entries in the same bucket but distinguishes them using .equals().

Key Comparison:
When retrieving a value, HashMap checks:
First: Does the hash code match?
Then: Does .equals() return true?
If .equals() returns false, the keys are treated as distinct, even with the same hash code.


Q. Suppose you store users sessions in hashmap. How would you ensure thread safety?
Ans: 1. Use ConcurrentHashMap
The most recommended solution:
Map<String, Session> sessionMap = new ConcurrentHashMap<>();

2. Synchronize Access Manually
If you must use HashMap:
Map<String, Session> sessionMap = new HashMap<>();

synchronized (sessionMap) {
    sessionMap.put("user123", session);
}


Q. What is Maven and why do we use?
Ans: Apache Maven is a powerful build automation and project management tool used primarily for Java applications. It simplifies the process of building, 
testing, packaging, and managing dependencies in software projects.

Q. What is the difference between git rebase and git marge?
Ans: git merge
Combines two branches by creating a new merge commit that ties together the histories of both branches.

git rebase
Moves or replays commits from one branch onto another, creating a linear history.


Q. What Is git cherry-pick?
Ans: git cherry-pick lets you copy a specific commit from one branch and apply it to another.

**************************************************************************************************************************************************************
INFOSYS Interview Questions (https://www.youtube.com/watch?v=EWpsZb45T_4)
Q. How microservice will work as a eureka server?
Ans: 1. Add Eureka Server Dependency in pom.xml
2.Enable Eureka Server in your main class:

@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}

3. Configure application.yml or application.properties

server:
  port: 8761

eureka:
  client:
    register-with-eureka: false
    fetch-registry: false


Q. We have application properties or yaml files, how to get those porperties in our code?
Ans: 1. Using @Value Annotation
# application.properties
app.name=MyApp

@Value("${app.name}")
private String appName;

2. Using @ConfigurationProperties

# application.yml
app:
  name: MyApp
  version: 1.0

@Component
@ConfigurationProperties(prefix = "app")
public class AppProperties {
    private String name;
    private String version;

    // getters and setters
}


Q. What is the difference between inject mock and mock?
Ans: @Mock - Creates a mock object of a class or interface.

@Mock
private UserService userService;

@InjectMocks - Creates an instance of the class under test, and injects the mocks into it.

@InjectMocks
private UserController userController;


Q. I have a employee list where they have name and price. Now I want name starts with N and price greater than 500. Also I want submission of this.
How to get this usning stream?
Ans: Using Java Streams by combining filter() and mapToDouble() with sum().

public class Employee {
    private String name;
    private double price;

    public Employee(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() { return name; }
    public double getPrice() { return price; }

    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(
            new Employee("Nina", 600),
            new Employee("Nick", 450),
            new Employee("Nora", 550),
            new Employee("Alex", 700)
        );

        double total = employees.stream()
            .filter(e -> e.getName().startsWith("N") && e.getPrice() > 500)
            .mapToDouble(Employee::getPrice)
            .sum();

        System.out.println("Total price of filtered employees: " + total);
    }
}


Q. what is nexus?
Ans: Nexus is a repository management tool used to store, manage, and distribute software components like libraries, binaries, and containers. It's 
especially popular in DevOps and Java development environments.


************************************************************************************************************************************************
WIPRO Interview (https://www.youtube.com/watch?v=W_O-vfafLIc)

Q. How microservices are different from web services?
Ans: 
Feature		Microservices Architecture						Web Services Architecture
Definition		A design pattern where an app is split into small,          A method for communication between systems over a network
			independent services							
Scope	Entire	application architecture						Communication mechanism (e.g., SOAP, REST)
Fault Isolation	Failure in one service doesn’t affect others			Failure can impact the whole system


Q. Why we use lambda function in java8?
Ans: 1. Concise Code - Reduces boilerplate code for anonymous classes.
2. Functional Programming - Enables passing behavior as data.
Works seamlessly with Streams API for filtering, mapping, and reducing collections.


Q. What is the differnce between IOC and dependency injection?
Ans: IoC is a design principle where the control of object creation and dependency management is transferred from the program itself to a container or framework.
Instead of your code creating and managing dependencies, the framework does it for you.
It’s a broad concept that includes various techniques like:
Dependency Injection
Service Locator

Dependency Injection (DI)
DI is a specific implementation of IoC where dependencies are injected into a class rather than the class creating them itself.


Q. What is @Qualifier annotation and what error we can get if we don't use it?
Ans: The @Qualifier annotation in Spring is used to resolve ambiguity when multiple beans of the same type exist. It tells Spring exactly which bean to inject 
when there’s more than one candidate. For Example - 

@Component("dog")
public class Dog implements Animal {}
@Component("cat")
public class Cat implements Animal {}

Now if we inject Animal directly it wiil throw error
@Autowired
private Animal animal;
NoUniqueBeanDefinitionException: expected single matching bean but found 2

Fix with @Qualifier
@Autowired
@Qualifier("dog")
private Animal animal;


Q. How you use jwt token?
Ans: 1. User Logs In - 
The user sends credentials (username/password) to your login endpoint. If valid, the server generates a JWT and returns it.
2. Client Stores the Token - 
The client (browser, mobile app) stores the token—usually in localStorage or sessionStorage.
3. Client Sends Token with Requests - 
For protected endpoints, the client sends the token in the Authorization header
4. Server Validates the Token - 
On each request, the server: Extracts the token. Verifies the signature and expiration. Parses the claims (e.g., username, roles)
5. Access Granted or Denied - 
If the token is valid, the request proceeds. If invalid or expired, the server returns 401 Unauthorized.


Q. What do you mean by continuous integration and continuous development?
Ans: Continuous Integration (CI) means frequently merging code changes into a shared repository with automated testing, while Continuous Delivery/Deployment 
(CD) means automatically preparing or releasing those changes to production. Together, CI/CD streamlines software development and delivery.

Q. What is static method?
Ans: A static method in Java is a method that belongs to the class itself, rather than to instances of the class. You can call it without creating an object of the class.

Q. Why the main method is static in java?
Ans: The main method in Java is static because it needs to be called by the JVM without creating an instance of the class.

Q. What is blank final variable in java?
Ans: A blank final variable in Java is a final variable that is declared but not initialized at the time of declaration. It must be assigned exactly once before the 
constructor or method completes execution.

public class Employee {
    final int id; // blank final variable

    public Employee(int id) {
        this.id = id; // must be initialized here
    }
}


Q. How Java object is stored in a memory?
Ans: In Java, objects are stored in the heap memory, while references to those objects are stored in the stack memory. The JVM manages this memory allocation dynamically 
during runtime.

Q. Suppose you have list of strings and you have to concatenate all using stream api?
Ans: You can concatenate a list of strings using the Java Stream API with the Collectors.joining() method.

public class ConcatenateStrings {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("Java", "Stream", "API", "Example");

        String result = words.stream()
                             .collect(Collectors.joining(" ")); // Use space or any delimiter

        System.out.println(result);
    }
}

Q. What is the use of functional interface in java8?
Ans: In Java 8, functional interfaces enable the use of lambda expressions and method references, allowing developers to write cleaner, more expressive, and functional-style code.


Q. What is predicate in terms of functional interface?
Ans: In Java 8, a Predicate<T> is a functional interface that represents a boolean-valued function of one argument. It's commonly used for filtering or conditional checks, 
especially in the Stream API.

**********************************************************************************************************************************************************

Q. Features of Java 17?
Ans: 1. Sealed Classes
Restrict which classes can extend or implement a class/interface.
Improves control over inheritance and enhances security.
2. Removal of Deprecated Features
Deprecated APIs and features from earlier versions (like the Applet API) have been removed.
Helps clean up legacy code and improve performance.
3.Improved garbage collection (G1 and ZGC). Better memory management and reduced latency.



Q. What is sealed classes and why do we need sealed classes?
Ans: Sealed classes in Java are a feature introduced in Java 17 that allow you to restrict which other classes or interfaces can extend or implement them. This gives you explicit 
control over inheritance, making your code more secure, predictable, and easier to maintain.
A sealed class is declared using the sealed keyword and specifies a list of permitted subclasses using the permits clause.

public sealed class Shape permits Circle, Square, Triangle {}

Each permitted subclass must be declared as either:
final (cannot be extended further)
sealed (can restrict further)
non-sealed (open to extension)  
For Example:

public final class Circle extends Shape {}
public non-sealed class Square extends Shape {}

Why Do We Need Sealed Classes?
1. Controlled Inheritance
You define exactly which classes can extend your base class—no surprises from third-party extensions.
2. Improved Security and Maintainability
Limits subclassing to known, trusted classes—useful in APIs and frameworks.



Q. Difference between stream and parallel stream?
Ans: The key difference between stream() and parallelStream() in Java is that stream() processes elements sequentially using a single thread, while parallelStream() splits the 
work across multiple threads for concurrent execution, potentially improving performance for large datasets.

Feature		stream() (Sequential)		parallelStream() (Parallel)
Execution		Single thread			Multiple threads (ForkJoinPool)
Performance		Slower for large datasets	Faster for CPU-intensive tasks with large datasets


Q. Why can't we use parallel stream every time?
Ans: 1. Overhead for Small Tasks
Parallel streams use the ForkJoinPool, which adds thread management overhead.
For small datasets or lightweight operations, this overhead can make parallel streams slower than regular streams.
2. Thread Safety Issues
If your stream operations involve shared mutable state, parallel execution can cause race conditions or inconsistent results.


Q. What Is Encapsulation?
Ans: Encapsulation means hiding internal state and requiring all interaction to go through controlled access points. Typically, this is done by:
Declaring fields as private.
Providing public getters/setters to access or modify them.


Q. Is it possible to add encaptualtion without getters and setters?
Ans: Yes, it's possible to achieve encapsulation in Java without using getters and setters, though they are the most common way to expose and control access to private fields.

Constructor-Based Encapsulation
You can initialize fields via constructors and never expose them:

public class User {
    private final String name;

    public User(String name) {
        this.name = name;
    }

    public void printName() {
        System.out.println("Name: " + name);
    }
}


Q. How encapsulation improves security?
Ans: Encapsulation improves security in Java by restricting direct access to an object's internal state and enforcing controlled interaction through well-defined interfaces.
1. Protects Internal Data
Fields are marked private, so they can't be accessed or modified directly from outside the class. Only trusted methods within the class can manipulate the data.
public class User {
    private String password;

    public void setPassword(String password) {
        if (isValid(password)) {
            this.password = password;
        }
    }
}
2. Enforces Validation and Rules
You can add logic to setters or methods to validate inputs before updating fields. This prevents inconsistent or dangerous states.
public void setAge(int age) {
    if (age > 0) this.age = age;
}

****************************************************************************************************************************************************************
MPHASIS Interview (https://www.youtube.com/watch?v=CGdtGXT8q2w&list=PLFBrmB-BmOrKVuhVZa-7W9fPVNw-Z8nql&index=5)

Q. What is polymorphism?
Ans: Polymorphism - poly means many and phism means forms means ability of an object, method, or operator to take on many forms. We have two types of polymorphism. 
Complie time that is method overloading (in a class method names are same but parameters are different). And Run time polymorphism that is method overriding (Method name 
and parameter are same but in class is different.

Q. Wait and sleep in multithreading? 
Ans: sleep() Method
Defined in: Thread class
Purpose: Pauses the current thread for a specified time.
Behavior: Does not release locks (monitors) if the thread holds them. After the sleep duration, the thread becomes runnable again.

wait() Method
Defined in: Object class
Purpose: Causes the current thread to wait until another thread calls notify() or notifyAll() on the same object.
Behavior: Must be called inside a synchronized block/method. Releases the lock on the object while waiting. Thread remains in the waiting state until notified.

Q. What is executor service?
Ans: In Java, ExecutorService is a framework provided by the java.util.concurrent package that simplifies running tasks asynchronously using a pool of threads. 
Instead of manually creating and managing threads, you submit tasks to an ExecutorService, and it handles scheduling, execution, and lifecycle management for you.


Q. How to achieved the singleton design pattern?
Ans: The Singleton Design Pattern ensures that a class has only one instance throughout the application and provides a global point of access to that instance. It’s 
one of the most commonly used creational design patterns in Java.
Steps to Achieve Singleton in Java
1. Private Constructor - Prevents direct instantiation of the class from outside.
2. Private Static Instance - Holds the single instance of the class.
3. Public Static Accessor Method - Provides a global access point to the instance.

public class Singleton {
    private static Singleton instance;

    private Singleton() {
        // private constructor
    }

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // create only once
        }
        return instance;
    }
}


Q. How to break singleton?
Ans: Ways to Break Singleton
1. Reflection - Reflection can access private constructors and create new instances.
2. Serialization & Deserialization - If a singleton class implements Serializable, deserializing it can create a new instance.
3. Cloning - If the singleton class implements Cloneable, calling clone() can create another instance.


Q. What is composit key in Java?
Ans: In Java, the term composite key usually comes up in the context of databases and ORM frameworks (like Hibernate or JPA). It refers to a primary key made up of 
multiple fields (columns) that together uniquely identify an entity. When mapping a database table to a Java class, sometimes a single field (like id) isn’t enough 
to uniquely identify a record. In that case, you define a composite key using multiple fields.

Using @IdClass - You define a separate key class and reference it in the entity.

// Composite Key Class
public class StudentCourseId implements Serializable {
    private int studentId;
    private int courseId;

    // getters, setters, equals(), hashCode()
}

// Entity Class
@Entity
@IdClass(StudentCourseId.class)
public class StudentCourse {
    @Id
    private int studentId;

    @Id
    private int courseId;

    private String grade;
}


Q. Lazy loading and eager loading?
Ans: Lazy Loading
Definition: Data is loaded on demand, i.e., only when it is accessed for the first time.
Behavior: When you fetch an entity, its related entities are not immediately loaded. Instead, a proxy object is created, and the actual data is fetched only 
when you call a getter.
Pros: Saves memory and improves performance if related data is not always needed. Reduces initial query load.

@Entity
class Student {
    @OneToMany(mappedBy = "student", fetch = FetchType.LAZY)
    private List<Course> courses;
}


Eager Loading
Definition: Data is loaded immediately, i.e., at the time the parent entity is fetched.
Behavior: When you query an entity, all its related entities are also fetched in the same query (often using JOIN).
Pros : No risk of LazyInitializationException. Convenient if related data is always required.

@Entity
class Student {
    @OneToMany(mappedBy = "student", fetch = FetchType.EAGER)
    private List<Course> courses;
}


Q. Suppose I want to export spring boot application into a war file and deploy it in a dedicated server. How to achieve that?
Ans: Spring Boot applications are packaged as JARs (standalone with embedded Tomcat/Jetty). But if you want to deploy on a dedicated server with an external 
servlet container (like Tomcat, JBoss, WebSphere), you need to package it as a WAR file.
1. Update pom.xml - Change packaging type from jar to war -> 		<packaging>war</packaging>
Add dependency for spring-boot-starter-tomcat but mark it as provided (since the server already has Tomcat):
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-tomcat</artifactId>
    <scope>provided</scope>
</dependency>
2. Extend SpringBootServletInitializer
Modify your main application class to extend SpringBootServletInitializer. This allows the WAR to be deployed in an external servlet container.


Q. How one microsrvice consume another microservice?
Ans: REST API Calls - Microservices expose endpoints (/api/...) over HTTP. Another microservice calls these endpoints using an HTTP client 
(e.g., RestTemplate, WebClient in Spring Boot).

// Using RestTemplate
RestTemplate restTemplate = new RestTemplate();
String response = restTemplate.getForObject("http://order-service/api/orders/123", String.class);


Q. An array is there and I want to pring only duplicate elements. How to do that?
Ans: Use Hashmap.

public class DuplicateElements {
    public static void main(String[] args) {
        int[] arr = {4, 5, 6, 7, 4, 5, 8, 9, 6};

        // Step 1: Create a HashMap to store frequencies
        Map<Integer, Integer> freqMap = new HashMap<>();

        // Step 2: Count occurrences
        for (int num : arr) {
            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);
        }

        // Step 3: Print duplicates
        System.out.println("Duplicate elements are:");
        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
            if (entry.getValue() > 1) {
                System.out.println(entry.getKey());
            }
        }
    }
}

****************************************************************************************************************************************************
UST GLOBAL Interview (https://www.youtube.com/watch?v=zKm9CrAojUc)

Q. Advantages of Java 8?
Ans: 1. Lambda Expressions - Enable writing cleaner, shorter, and more expressive code.
2. Stream API - Provides a functional way to process collections. Supports operations like map, filter, reduce.
3. New Date and Time API (java.time) - Replaces the old Date and Calendar classes with a modern, immutable API.
4. Default and Static Methods in Interfaces - Interfaces can now have method implementations.
5. Optional Class - Helps avoid NullPointerException by explicitly handling absence of values.


Q. What is thread?
Ans: A thread in Java is the smallest unit of execution within a program, often called a lightweight subprocess. It allows multiple tasks to run 
concurrently within the same application, sharing the same memory but executing independently.


Q. Difference between run and start in start?
Ans: run() Method - Defined in the Runnable interface and overridden in the Thread class.
Purpose: Contains the code that will be executed by the thread.
If you call run() directly, it behaves like a normal method call. It does not create a new thread; instead, it runs in the current thread.

start() Method - Defined in the Thread class.
Purpose: Starts a new thread of execution.
Behavior: Internally calls the run() method, but in a separate thread.


Q. Aggreagation and compostion concet in java?
Ans:In Object-Oriented Programming (OOP), especially in Java, Aggregation and Composition are two important concepts that describe relationships 
between classes. Both are forms of Association, but they differ in how strongly one object depends on another. 

Aggregation
Definition: A "Has-A" relationship where one class contains a reference to another, but the contained object can exist independently.
Dependency: Weak relationship.
Lifetime: The child object’s lifecycle is independent of the parent.
Example: A Department has Teachers. Even if the Department is deleted, the Teacher objects can still exist.

Composition
Definition: A "Has-A" relationship where one class contains another, but the contained object cannot exist without the parent.
Dependency: Strong relationship.
Lifetime: The child object’s lifecycle is dependent on the parent.
Example: A House has Rooms. If the House is destroyed, the Rooms are destroyed too.


Q. Can we override the constructor?
Ans: No.

Q. What is request body annotation in spring boot?
Ans: The @RequestBody annotation in Spring Boot is used to bind the HTTP request body to a Java object, automatically deserializing JSON or XML into that object.

How It Works
When a client sends data in the body of an HTTP request (e.g., JSON in a POST request), Spring uses HttpMessageConverters to convert that data into a Java object.
The @RequestBody annotation tells Spring to look at the request body and map it to the parameter of your controller method.


Q. Difference between controller and rest controller?
Ans: @Controller is used in Spring MVC for traditional web applications, typically returning HTML views.
@RestController is used for RESTful APIs, automatically returning JSON/XML responses without needing @ResponseBody on each method.

Q. What is Controller advice?
Ans: In Spring, @ControllerAdvice is a special annotation used to define global exception handling, data binding, and model attributes that apply to multiple 
controllers. It centralizes common logic (like error handling) instead of repeating it in each controller.

Q. Is session object thread safe in hibernate?
Ans: The Hibernate Session object is not thread-safe. A Session represents a single unit of work with the database.
If multiple threads access the same Session concurrently, they can corrupt its state or cause unpredictable behavior.
Hibernate’s design expects one session per thread/request.

Q. What is second level caching in hibernate?
Ans: In Hibernate, the second-level cache is a shared cache that stores entity data across multiple sessions. Unlike the first-level cache (which is 
session-specific), the second-level cache improves performance by reducing database hits for frequently accessed entities across the entire application.

Q. What is aggregator desing pattern in microservice?
Ans: The Aggregator pattern is used when a client request requires data from multiple microservices. Instead of the client calling each service individually, 
an aggregator service calls the required microservices, collects their responses, and combines them into a single response.


Q. What is circuit breaker desing pattern?
Ans: The Circuit Breaker Design Pattern in microservices is a resilience pattern that prevents repeated calls to a failing service. It “trips” after detecting 
multiple failures, stops further requests temporarily, and only allows calls again once the service shows signs of recovery

Q. what is Hystrix?
Ans: Hystrix is a Java library developed by Netflix that implements the Circuit Breaker design pattern to make microservices more resilient and fault‑tolerant.

Q. What are rest template methods?
Ans: Get. Post, Put, Delete. 


***********************************************************************************************************************************************************
HCL Interview (https://www.youtube.com/watch?v=rtLRyFcuNJI&list=PLFBrmB-BmOrKVuhVZa-7W9fPVNw-Z8nql&index=6)

Q. Suppose I have a arraylist of students with their marks. Now I want to sort it based on marks. Use Java8?
Ans: 
class Student {
    String name;
    int marks;

    Student(String name, int marks) {
        this.name = name;
        this.marks = marks;
    }

    @Override
    public String toString() {
        return name + " - " + marks;
    }
}

public class SortStudents {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student("Alice", 85));
        students.add(new Student("Bob", 72));
        students.add(new Student("Charlie", 90));

//using lambda
students.sort((s1, s2) -> Integer.compare(s1.marks, s2.marks));
// Print sorted list
students.forEach(System.out::println);


//Using stream
students.stream()
        .sorted(Comparator.comparingInt(s -> s.marks))
        .forEach(System.out::println);



Q. Give code snippet to apply singleton design pattern.
Ans: 
public class Singleton {

    // Step 1: private static instance
    private static Singleton instance;

    // Step 2: private constructor to prevent instantiation
    private Singleton() {
        System.out.println("Singleton instance created");
    }

    // Step 3: public static method to provide access
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // create only once
        }
        return instance;
    }

    // Example method
    public void showMessage() {
        System.out.println("Hello from Singleton!");
    }
}

public class Main {
    public static void main(String[] args) {
        Singleton obj1 = Singleton.getInstance();
        Singleton obj2 = Singleton.getInstance();

        obj1.showMessage();

        // Verify both references point to the same object
        System.out.println(obj1 == obj2); // true
    }
}


Q. What is factory design patter?
Ans: Definition: A design pattern that defines an interface for creating objects, but lets subclasses decide which class to instantiate.
Purpose: Encapsulates object creation logic, making code more flexible and easier to maintain.


Q. What is SOLID principles?
Ans: 1. S – Single Responsibility Principle (SRP)
Definition: A class should have only one reason to change.
Meaning: Each class should do one thing only (one responsibility).
Example:
❌ A Student class that handles student data and writes logs.
✅ Separate Student class (for data) and Logger class (for logging).

2. O – Open/Closed Principle (OCP)
Definition: Software entities should be open for extension but closed for modification.
Meaning: You should be able to add new functionality without changing existing code.

3. L – Liskov Substitution Principle (LSP)
Definition: Subtypes must be substitutable for their base types.
Meaning: If class B is a subclass of class A, then objects of A should be replaceable with objects of B without breaking the program.
Example:
✅ A Rectangle class and a Square class should behave consistently when used as a Shape.
❌ If Square changes behavior unexpectedly (e.g., breaks area calculation), it violates LSP.

4. I – Interface Segregation Principle (ISP)
Definition: Clients should not be forced to depend on interfaces they do not use.
Meaning: Create small, specific interfaces instead of large, general ones.
Example:
❌ A Printer interface with methods print(), scan(), fax().
✅ Split into Printable, Scannable, Faxable interfaces. A simple printer only implements Printable.

5. D – Dependency Inversion Principle (DIP)
Definition: Depend on abstractions, not on concrete implementations.
Meaning: High-level modules should not depend on low-level modules; both should depend on abstractions.
Example:
❌ A PaymentService directly depends on CreditCardPayment.
✅ PaymentService depends on a Payment interface, and CreditCardPayment or UPIPayment implement that interface.


Q. What is assertions?
Ans: Assertions are statements used in testing to check whether the actual output of code matches the expected output. They act like checkpoints 
in your test cases: if an assertion fails, the test fails.Assertions are fundamental in frameworks like JUnit (Java), TestNG, and other testing libraries.
For Example:

class CalculatorTest {
    @Test
    void testAddition() {
        int result = Calculator.add(2, 3);
        
        // Assertion: expected 5, actual result
        assertEquals(5, result, "Addition should return 5");
    }
}

assertEquals(expected, actual) → checks if values are equal. If result is not 5, the test fails.
